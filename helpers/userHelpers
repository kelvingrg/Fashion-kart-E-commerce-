var db = require("../config/connection");
var collection = require("../config/collections");
const bcrypt = require("bcrypt");
var objectId = require("mongodb").ObjectId;
const Razorpay = require('razorpay');
const CC = require("currency-converter-lt");
require("dotenv").config()
const moment = require("moment");

let respond = {};
// / razor pay configaration
var instance = new Razorpay({key_id: process.env.KEY_ID, key_secret: process.env.KEY_SECRET});


// paypal configuration
const paypal = require('paypal-rest-sdk');
const {response} = require("express");
const { resolve } = require("path");
paypal.configure({mode: "sandbox", client_id: 'ATVfUdlaEds_REEqb851ftHbOZRfYuSJrVBTxI1iUWCU2my_lpNjwkEfx82dpwe5T5m_NoMSCV1Vbdbq', client_secret: 'EBWuUe0r61_vNU4N2kK3EykHQR7xhx7nfC_YS4x472Lwr2Exay0a14Uly2DWPl8P18l6njI8FSRYOnmf'});


module.exports = {
    doSignup: (userData) => {
        console.log(userData);
        return new Promise(async (resolve, reject) => {
            console.log("dosignup user data ");
            userData.password = await bcrypt.hash(userData.password, 10); // this 10 refers salt value
            db.get().collection(collection.USER_COLLECTION).insert(userData).then((data) => {
                console.log(data);
                resolve(data.insertId);
            });
        });
    },
    statusUpdate: (userData) => {
        db.get().collection(collection.USER_COLLECTION).updateOne({
            email: userData.email
        }, {
            $set: {
                state: true
            }
        }).then((data) => {});
    },

    userExist: (userData) => {
        console.log("user exist-user data ");
        return new Promise(async (resolve, reject) => {
            let response = {};
            let email = await db.get().collection(collection.USER_COLLECTION).findOne({email: userData.email});
            let phone = await db.get().collection(collection.USER_COLLECTION).findOne({mobileNumber: userData.mobileNumber});
            console.log(email, phone);
            if (email || phone) {
                if (email) {
                    console.log("same email");
                    response.email = true;
                } else {
                    response.email = false;
                }
                if (phone) {
                    console.log("existing mobile number");
                    response.phone = true;
                } else {
                    response.phone = false;
                }

                resolve(response);
            } else {
                response.noexist = true;
                resolve(response);
            }
        });
    },

    doLogin: (userData) => {
        return new Promise(async (resolve, reject) => { // console.log(userData)

            let user = await db.get().collection(collection.USER_COLLECTION).findOne({email: userData.email});

            if (user) {
                if (user.state == true) {
                    bcrypt.compare(userData.password, user.password).then((status) => {
                        if (status) {
                            console.log("success");
                            respond.user = user;
                            respond.status = true;
                            resolve(respond);
                        } else {
                            console.log("password mismatch");
                            resolve({status: false});
                        }

                    });
                } else {
                    respond.block = true;
                    console.log(respond.block);
                    resolve(respond);
                }


            } else {
                console.log("mail id  mismatch");
                resolve({status: false});
            }


        });
    },
    doGetUser: (userData) => {

        return new Promise(async (resolve, reject) => {
            let user = await db.get().collection(collection.USER_COLLECTION).findOne({email: userData.email}).then((data) => {;
                resolve(data);
            });
        });
    },
    doMobileNumber: (userData) => {
        return new Promise(async (resolve, reject) => {
            let number = await db.get().collection(collection.USER_COLLECTION).findOne({mobileNumber: userData.mobileNumber});
            resolve(number);
        });
    },
    deleteUser: (userId) => {
        return new Promise((resolve, reject) => {
            db.get().collection(collection.USER_COLLECTION).deleteOne().then((response) => {
                resolve(response);
            });
        });
    },
    banUser: (userId) => {
        return new Promise(async (resolve, reject) => {
            await db.get().collection(collection.USER_COLLECTION).updateOne({
                _id: objectId(userId)
            }, {
                $set: {
                    state: false
                }
            }).then((response) => {
                resolve(response);
            });
        });
    },
    unbanUser: (userId) => {
        return new Promise(async (resolve, reject) => {
            await db.get().collection(collection.USER_COLLECTION).updateOne({
                _id: objectId(userId)
            }, {
                $set: {
                    state: true
                }
            }).then((response) => {
                resolve(response);
            });
        });
    },
    updatePassword: (newPassword, user) => {
        let response = {};
        return new Promise(async (resolve, reject) => {
            await bcrypt.compare(newPassword.oldPassword, user.password).then(async (status) => {
                if (status) {
                    let hashedpassword = await bcrypt.hash(newPassword.password, 10);
                    await db.get().collection(collection.USER_COLLECTION).updateOne({
                        email: user.email
                    }, {
                        $set: {
                            password: hashedpassword
                        }
                    }).then((response) => {
                        response.updatepass = true;
                        resolve(response);
                    });
                } else {
                    response.updatepass = false;
                    resolve(response);
                }
            });
        });
    },

    // update peprsonal data of user
    updatePersonalData: (newUserData, user) => {
        return new Promise(async (resolve, reject) => {
            await db.get().collection(collection.USER_COLLECTION).updateOne({
                email: user.email
            }, {
                $set: {
                    firstName: newUserData.firstName,
                    lastName: newUserData.lastName,
                    address: newUserData.address,
                    city: newUserData.city,
                    country: newUserData.country,
                    pinCode: newUserData.pinCode
                }
            }).then((response) => {
                resolve(response);
                console.log(response);
            });
        });
    },

    // add to cart

    addToCart: (prodId, userId) => {
        let prodObj = {
            item: objectId(prodId),
            quantity: 1
        }
        return new Promise(async (resolve, reject) => {
            let userCart = await db.get().collection(collection.CART_COLLECTION).findOne({user: objectId(userId)})
            if (userCart) {
                let proExist = userCart.products.findIndex(product => product.item == prodId)
                if (proExist != -1) {
                    db.get().collection(collection.CART_COLLECTION).updateOne({
                        user: objectId(userId),
                        'products.item': objectId(prodId)
                    }, {
                        $inc: {
                            'products.$.quantity': 1
                        }
                    }).then(() => {
                        resolve()
                    })
                } else {
                    db.get().collection(collection.CART_COLLECTION).updateOne({
                        user: objectId(userId)
                    }, {
                        $push: {
                            products: prodObj
                        }
                    }).then(() => {
                        resolve();
                    })
                }
            } else {
                let cartObj = {
                    user: objectId(userId),
                    products: [prodObj]
                }
                db.get().collection(collection.CART_COLLECTION).insertOne(cartObj).then(() => {
                    resolve()
                })
            }
        })

    },

    // get cart products

    getCartProducts: (userId) => {
        return new Promise(async (resolve, reject) => {

            let cartItems = await db.get().collection(collection.CART_COLLECTION).aggregate([
                {
                    $match: {
                        user: objectId(userId)
                    }
                },
                {
                    $unwind: '$products'
                },
                {
                    $project: {
                        item: '$products.item',
                        quantity: '$products.quantity'
                    }
                },
                {
                    $lookup: {
                        from: collection.PRODUCT_COLLECTION,
                        localField: 'item',
                        foreignField: '_id',
                        as: 'product'

                    }
                }, {
                    $project: {
                        item: 1,
                        quantity: 1,
                        product: {
                            $arrayElemAt: ['$product', 0]
                        }
                    }

                }


            ]).toArray()
            resolve(cartItems)
        })
    },
    // get cart count
    getCartItemsCount: (userId) => {
        return new Promise(async (resolve, reject) => {
            let cart = await db.get().collection(collection.CART_COLLECTION).findOne({user: objectId(userId)})
            if (cart) {
                count = cart.products.length
                resolve(count)

            } else 
                resolve(0)


            


        })
    },
    // chaange product quantity at cart
    changeProductQuantity: (details) => {
        console.log(details, 'at userhelpers');
        let count = parseInt(details.count)
        console.log(count, 'count after pasre')
        return new Promise((resolve, reject) => {
            console.log(details)
            db.get().collection(collection.CART_COLLECTION).updateOne({
                _id: objectId(details.cart),
                'products.item': objectId(details.product)
            }, {
                $inc: {
                    'products.$.quantity': count
                }
            }).then((response) => {
                resolve({status: true})
            })
        })

    },
    // cart total amount
    getTotalAmount: (userId) => {
        return new Promise(async (resolve, reject) => {

            let total = await db.get().collection(collection.CART_COLLECTION).aggregate([
                {
                    $match: {
                        user: objectId(userId)
                    }
                },
                {
                    $unwind: '$products'
                },
                {
                    $project: {
                        item: '$products.item',
                        quantity: '$products.quantity'
                    }
                },
                {
                    $lookup: {
                        from: collection.PRODUCT_COLLECTION,
                        localField: 'item',
                        foreignField: '_id',
                        as: 'product'

                    }
                }, {
                    $project: {
                        item: 1,
                        quantity: 1,
                        product: {
                            $arrayElemAt: ['$product', 0]
                        }
                    }

                }, {
                    $group: {
                        _id: null,
                        total: {
                            $sum: {
                                $multiply: [
                                    {
                                        $toInt: '$quantity'
                                    }, {
                                        $toInt: '$product.offerPrice'
                                    }
                                ]
                            }
                        }
                    }
                }


            ]).toArray()
            console.log(total)
            resolve(total)
        })
    },
    getCartProductList: (userId) => {
        return new Promise(async (resolve, reject) => {
            let cart = await db.get().collection(collection.CART_COLLECTION).findOne({user: objectId(userId)})
    
            resolve(cart.products)
        })
    },

    // order place
    placeOrder:async(order, products, total,totalValue,couponApplied) => {
        console.log(order,'................adorder')
        console.log(order.address,'................adorder')
        
        
      let addressData= await db.get().collection(collection.ADDRESS_COLLECTION).aggregate([{$match:{userId:objectId(order.userId)}},{$unwind:"$address"},{$match:{"address._id":order.address}},{$project:{address:1}}]).toArray()
      console.log(addressData,'................addressFata')
      console.log(addressData[0].address.firstName,'................addressFata')
      console.log(addressData[0].firstName,'................addressFata')
      console.log(addressData[0].firstName,'................addressFata')
        return new Promise((resolve, reject) => {
            let status = order.paymentMethod == 'COD' ? 'placed' : 'pending'
            let orderObj = {
                deliveryDetails: {
                    name: addressData[0].address.firstName+" "+addressData[0].address.lasttName,
                    address: addressData[0].address.address,             
                    city: addressData[0].address.city,
                    country: addressData[0].address.country,
                    pin: addressData[0].address.pinCode,              
                    mobileNumber: addressData[0].address.mobileNumber,
                },
                userId: objectId(order.userId),
                paymnetMethod: order.paymentMethod,
                products: products,
                totalAmount:totalValue[0].total,
                couponCodeApplied:couponApplied.couponData.couponCode,
                couponId:couponApplied.couponData._id,
                finalAmount:total,
                date: new Date().toDateString(),
                timeStamp: new Date(),
                status: status,
                cancellation: false
            }
            db.get().collection(collection.ORDER_COLLECTION).insertOne(orderObj).then((response) => {
                // db.get().collection(collection.CART_COLLECTION).deleteOne({
                //     user: objectId(order.userId)
                // })
                resolve(response)
            })
        })
    },
    // to delete cart items , which is called only after once  order get placed  
    deleteCartItems:async(userId)=>{
    //    await db.get().collection(collection.CART_COLLECTION).deleteOne({
    //             user: objectId(userId)
    //     })
           
        },
    // razor pay integration

    generateRazorPay: (orderId, total) => {
        console.log(orderId, total)
        return new Promise((resolve, reject) => {
            var options = {
                amount: total, // amount in the smallest currency unit
                currency: "INR",
                receipt: "" + orderId
            };
            instance.orders.create(options, function (err, order) {
                console.log(order, "order at userhelpers")
                resolve(order)
            })

        })
    },

    // paypal integration


    generatePayPal: (orderId, totalPrice) => {
        console.log('paypal  at us.help step........... 2 ');
        return new Promise((resolve, reject) => {
            const create_payment_json = {
                "intent": "sale",
                "payer": {
                    "payment_method": "paypal"
                },
                "redirect_urls": {
                    return_url: "http://localhost:3000/success",
                    cancel_url: "http://localhost:3000/cancel"
                },
                "transactions": [
                    {
                        "item_list": {
                            "items": [
                                {
                                    "name": "Red Sox Hat",
                                    "sku": "001",
                                    "price": totalPrice,
                                    "currency": "USD",
                                    "quantity": 1
                                }
                            ]
                        },
                        "amount": {
                            "currency": "USD",
                            "total": totalPrice
                        },
                        "description": "Hat for the best team ever"
                    }
                ]
            };

            paypal.payment.create(create_payment_json, function (error, payment) {
                if (error) {
                    console.log("paypal int. err stp ...4", error);
                    throw error;

                } else {
                    resolve(payment);
                }
            });
        });
    },

    // delete one product from cart

    deleteOneCarProduct: (prodData) => {
        console.log(prodData, 'reached at user helpers ');
        return new Promise(async (resolve, reject) => {
            await db.get().collection(collection.CART_COLLECTION).updateOne({
                user: objectId(prodData.userId)
            }, {
                $pull: {
                    products: {
                        item: objectId(prodData.prodId)
                    }
                }
            }).then((response) => {
                resolve({status: true})
            })

        })
    },
    // order history for  cx
    orderHistory: (userId) => {
        return new Promise(async (resolve, reject) => {
            await db.get().collection(collection.ORDER_COLLECTION).find({userId: objectId(userId)}).toArray().then((response) => {
                resolve(response)
                console.log(response)
            })
        })

    },
    // view order details after order history
    viewOrderDetails: (orderId,) => {
       
        let response = {}

        return new Promise(async (resolve, reject) => {
            response.productData = await db.get().collection(collection.ORDER_COLLECTION).aggregate([
                {
                    $match: {
                        _id: objectId(orderId)
                    }
                }, {
                    $unwind: '$products'
                }, {
                    $project: {
                        item: '$products.item',
                        quantity: '$products.quantity'


                    }
                }, {
                    $lookup: {
                        from: collection.PRODUCT_COLLECTION,
                        localField: 'item',
                        foreignField: '_id',
                        as: 'product'

                    }
                },


            ]).toArray()

            response.orderData = await db.get().collection(collection.ORDER_COLLECTION).aggregate([
                {
                    $match: {
                        _id: objectId(orderId)
                    }
                }, {
                    $project: {
                        deliveryDetails: 1,
                        paymnetMethod: 1,
                        totalAmount: 1,
                        finalAmount:1,
                        status: 1,
                        date: 1
                    }
                }
            ]).toArray()

            resolve(response)
        })


    },
    verifyPayment: (details) => {
        return new Promise((resolve, reject) => {
            const crypto = require("crypto");
            let hmac = crypto.createHmac('sha256', process.env.KEY_SECRET)

            hmac.update(details['payment[razorpay_order_id]'] + '|' + details['payment[razorpay_payment_id]'])
            hmac = hmac.digest('hex')

            if (hmac == details['payment[razorpay_signature]']) {
                resolve()

            } else {
                reject()

            }
        })
    },
    changePaymentStatus: (orderId) => {
        return new Promise((resolve, reject) => {
            db.get().collection(collection.ORDER_COLLECTION).updateOne({
                _id: objectId(orderId)
            }, {
                $set: {
                    status: 'Placed'
                }
            }).then(async() => {

                db.get
                resolve()
            })
        })
    },
    test: (totalinr) => {

        let fromCurrency = "INR";
        let toCurrency = "USD";
        let amountToConvert = totalinr;
        let currencyConverter = new CC({from: fromCurrency, to: toCurrency, amount: amountToConvert});
        return new Promise(async (resolve, reject) => {
            await currencyConverter.convert().then((response) => {
                resolve(response)
            });


        })


    },
    validateCoupon:async(data,userId)=>{
        let response={}
        console.log('rexhed at fn checkCouponCode');
        let couponData=await db.get().collection(collection.COUPON_COLLECTION).findOne({couponCode:data.couponCode})
      
      
        if(couponData){

        if(couponData.startDate <= new Date()&&couponData.endDate >= new Date()){
            console.log('ifdata..1',userId,data.couponCode);
           let userCouponAvailability= await db.get().collection(collection.ORDER_COLLECTION).aggregate([{$match:{userId:objectId(userId),couponCodeApplied:data.couponCode}}]).toArray()  //,couponCodeApplied:data.couponCode
          console.log('userCouponAvailability',userCouponAvailability);
           if(userCouponAvailability.length){
            console.log('ifdata..2',userCouponAvailability);
            response.usage=true
            return(response)
            
           }
           else{
            console.log('ifdata..3');
            response.couponData=couponData
            return(response)
          }
        }else{
            console.log('ifdata..4');
            response.notAvailable=true
            return(response)
        }}
        else{
            console.log('ifdata..5');
            response.notAvailable=true
            return(response)
        }
    },
    getCatagory:async()=>{
      let catagoryData=  await db.get().collection(collection.CATAGORY_COLLECTION).find().toArray()
      return(catagoryData)


    },
    addNewAddress:async(addressData,userId)=>{
     let tempId = moment().format()   .toString()
    tempId.replace(/ /g,'')
    addressData._id=tempId
    await db.get().collection(collection.ADDRESS_COLLECTION).updateOne({userId:objectId(userId)},{$push:{address:addressData}},{upsert:true})

    },
    getAddress:(userId)=>{
       
        return new Promise(async(resolve,reject)=>{
       await db.get().collection(collection.ADDRESS_COLLECTION).find({userId:objectId(userId)}).toArray().then((addressData)=>{
        resolve(addressData)
        
       })
          
           
        })
       
       
    }

}
